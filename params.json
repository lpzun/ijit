{
  "name": "IJIT ",
  "tagline": "Interface for Just-In-Time translation from Boolean programs",
  "body": "### Introduction\r\nIJIT (**I**nterface for **J**ust-**I**n-**T**ime translation) is an API which helps users to transform their [transition-system] based algorithms to a version that can operate directly on [Boolean Programs]. Said an API avoids converting a Boolean program to a transition system up front, as up-front conversion usually incurs state space blowup.\r\n\r\n### Get Started\r\nAssuming you have downloaded () API [IJIT], we will now guided you through the process of using IJIT to transform your [transition-system] based algorithms to Boolean program based algorithm with little programing effort.\r\n\r\n`\r\n/**\r\n * @brief this is based on breadth-first search\r\n * @param n : the number of initial threads\r\n * @param s : the number of spawn   threads\r\n * @return bool\r\n *         true : if final state is reachable under n threads and s spawns\r\n *         false: otherwise\r\n */\r\nbool GKM::standard_FWS(const size_p& n, const size_p& s) {\r\n    auto spw = s;       /// the upper bound of spawns that can be fired\r\n    antichain worklist;\r\n    antichain explored;\r\n\r\n    for (const auto& initl : initl_TS)\r\n        worklist.emplace_back(initl, n);\r\n\r\n    while (!worklist.empty()) {\r\n        const auto tau = worklist.front();\r\n        worklist.pop_front();\r\n        /// step 1: if upward(tau) is already explored, then\r\n        ///         discard it\r\n        if (!this->is_maximal(tau, explored))\r\n            continue;\r\n\r\n        /// step 2: compute all post images; check if final\r\n        ///         state is coverable; maximize <worklist>\r\n        const auto& images = this->step(tau, spw);\r\n        for (const auto& _tau : images) {\r\n            /// return true if _tau covers final state\r\n            if (this->is_reached(_tau))\r\n                return true;\r\n            /// if upward(_tau) already exists, then discard it\r\n            if (!this->is_maximal(_tau, worklist))\r\n                continue;\r\n            /// maximize <worklist> in term of _tau\r\n            this->maximize(_tau, worklist);\r\n            worklist.emplace_back(_tau); /// insert into worklist\r\n        }\r\n        /// maximize <explored> in term of tau\r\n        this->maximize(tau, explored);\r\n        explored.emplace_back(tau); /// insert into explored\r\n    }\r\n    return false;\r\n}\r\n`\r\n### Authors and Contributors\r\nPeizun Liu (@lpzun) and [Thomas Wahl] (http://www.ccs.neu.edu/home/wahl/) are the main contributors. Peizun Liu is the main developer. \r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](http://www.ccs.neu.edu/home/lpzun/ijit/doc) or [contact support](http://www.ccs.neu.edu/home/lpzun/) and weâ€™ll help you sort it out.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}