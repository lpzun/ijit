/*******************************************************************************  
 ** Name:    	BoPP: lexer
 ** Authors: 	Peizun Liu
 ** Version: 	0.4
 ** Copyright: 	It belongs to Thomas Wahl's group in CAR Lab, CCIS, NEU
 ** Date:       Feb 2014
 ** Decription: BoPP is a C++ version of Boolean Program Parser. It aims to parse 
 *		Boolean programs and generate its control folow graph and the co-
 *		rresponding weakest precondition function for each statement.
 *
 *		lexer: Recognize tokens for the Boolean Program
 *              
 *              This version is to generate the DIMACS CNF format of WP, which
 *              can be used in (most) SAT solver directly
 ******************************************************************************/
%option noyywrap 
%option yylineno 
%{
	#include <cstdlib>     // C Standard General Utilities Library
	#include "bopp.tab.hh" // generated by bison

	/* define YY_DECL to declare the calling sequence for yylex to  
	 * match what the parser expects
	 */
	#define YY_DECL int yylex(yy::bp::semantic_type *yylval, \
				  yy::bp::location_type *yylloc)

	/* make location include the current token */
	#define YY_USER_ACTION yylloc->columns (yyleng);

	typedef yy::bp::token token;
%}

%s comment

%%

%{
	/* start where previous token ended:
	 * The step() method sets the beginning of the location equal to the end, 
	 * so the location now points to the end of the previous token.
	 */
	yylloc->step ();
%}
"/*"         		{ BEGIN(comment); }
<comment>[^*\n]*        /* eat anything that's not a '*' */
<comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<comment>\n             
<comment>"*"+"/"        { BEGIN(INITIAL); }

"//"[^\n]+\n  

"begin" 		 { return token::T_BEGIN; }
"end"			 { return token::T_END; }

"decl"			 { return token::T_DECL; }
"goto" 			 { return token::T_GOTO; }
"skip" 			 { return token::T_SKIP; }
"assume" 		 { return token::T_ASSUME; }
"assert" 		 { return token::T_ASSERT; }
"if" 			 { return token::T_IF; }
"fi"			 { return token::T_FI; }
"then"		         { return token::T_THEN; }
"void"			 { return token::T_VOID; }
"constrain"              { return token::T_CSTR; }
"start_thread"           { return token::T_START_THREAD; }
"end_thread"             { return token::T_END_THREAD; }
"atomic_begin"           { return token::T_ATOMIC_BEGIN; }
"atomic_end"             { return token::T_ATOMIC_END; }
"wait"                   { return token::T_WAIT; }
"broadcast"              { return token::T_BROADCAST; }

"*" 			 { return token::T_NONDET; }
":=" 			 { return token::T_ASSIGN; }
"="			 { return token::T_EQ_OP; }
"!="			 { return token::T_NE_OP; }
"&"			 { return token::T_AND; }
"&&"			 { return token::T_AND; }
"|"			 { return token::T_OR; }
"||"			 { return token::T_OR; }
"?"			 { return token::T_TERNARY; }
";"			 { return (';'); }
","			 { return (','); }
"'"			 { return ('\''); }
":"			 { return (':'); }
"("			 { yylval->t_str = strdup(yytext); return ('('); }
")"			 { yylval->t_str = strdup(yytext); return (')'); }
"!"			 { return ('!'); }
"^"			 { return ('^'); }

[0-9]+ 			  { yylval->t_val = atoi(yytext);   return token::T_INT; }
[a-zA-Z_\'][a-zA-Z0-9_$]* { yylval->t_str = strdup(yytext); return token::T_IDEN; }

[ \t\n\v\f]		 { }
. 			 { /* ignore bad characters */ }
%%

